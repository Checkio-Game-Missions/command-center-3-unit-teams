<style>
    pre.example {
        border: 1px solid #aaa;
        border-radius: 3px;
        background: #eee;
        margin-left: 20px;
        padding: 5px;
        overflow: auto;
    }

    p.indent {
        margin-left: 20px;
    }
</style>

<p>
    В задании
    <a href="http://www.checkio.org/mission/find-friends/share/3061fec1b35588e4bae8ad69db073aab/">
        "Как найти друзей" ("How to find friends")
    </a>, было бы удобно работать, используя специальную структуру данных. В этом задании мы
    разработаем структуру данных, которую будем применять для хранения и обработки социальной сети.

</p>

<p>
    Класс "Friends" должен содержать данные о людях (их имена) и о связях между ними.
    Имена представлены в виде текстовых строк, чувствительных к регистру.
    Связи не имеют направлений, то есть, если существует связь "sofia" с "nikola", это справедливо и
    в обратную сторону.

</p>

<p>
    <em>class</em> <strong>Friends</strong><em>(connections)</em>
</p>
<p class="indent">
    Возвращает новый объект, экземпляр класса Friends.
    Параметр <em>"connections"</em> имеет тип "итерируемый объект", содержащий множества (set) с
    двумя элементами в каждом.
    Каждая связь содержит два имени в виде текстовых строк.
    Связи могут повторяться в параметре инициализации, но в объекте хранятся только уникальные пары.
    Каждая связь имеет только два состояния - присутствует или не присутствует.
</p>

<pre class="example">
>>> Friends(({"a", "b"}, {"b", "c"}, {"c", "a"}, {"a", "c"})
>>> Friends([{"1", "2"}, {"3", "1"}])
</pre>
<br>

<p>
    <strong>add</strong>(connection)
</p>
<p class="indent">
    Добавляет связь в объект.
    Параметр <em>"connection"</em> является множеством (set) из двух имен (строк).
    Возвращает True, если заданная связь новая и не присутствует в объекте.
    Возвращает False, если заданная связь уже существует в объекте.
</p>
<pre class="example">
>>> f = Friends([{"1", "2"}, {"3", "1"}])
>>> f.add({"1", "3"})
False
>>> f.add({"4", "5"})
True
</pre>
<br>

<p>
    <strong>remove</strong>(connection)
</p>
<p class="indent">
    Удаляет связь из объекта.
    Параметр <em>"connection"</em> является множеством (set) из двух имен (строк).
    Возвращает True, если заданная связь существует в объекте.
    Возвращает False, если заданная связь не присутствует в объекте.
</p>
<pre class="example">
>>> f = Friends([{"1", "2"}, {"3", "1"}])
>>> f.remove({"1", "3"})
True
>>> f.remove({"4", "5"})
False
</pre>
<br>
<p>
    <strong>names</strong>()
</p>
<p class="indent">
    Возвращает множество (set) имён. Множество содержит имена, которые имеют хотя бы одну связь.
</p>
<pre class="example">
>>> f = Friends(({"a", "b"}, {"b", "c"}, {"c", "d"})
>>> f.names()
{"a", "b", "c", "d"}
>>> f.remove({"d", "c"})
True
>>> f.names()
{"a", "b", "c"}
</pre>
<br>
<p>
    <strong>connected</strong>(name)
</p>
<p class="indent">
    Возвращает множество (set) имён, которые связаны с именем, заданным параметром <em>"name"</em>.
    Если "name" не присутствует в объекте, возвращается пустое множество (set).
</p>
<pre class="example">
>>> f = Friends(({"a", "b"}, {"b", "c"}, {"c", "a"})
>>> f.connected("a")
{"b", "c"}
>>> f.connected("d")
set()
>>> f.remove({"c", "a"})
True
>>> f.connected("c")
set()
</pre>
<br>
<p>
    В этом задании все входные данные корректны, и выполнять их проверку не обязательно.
</p>

<p>
    <strong>Входные данные: </strong> Операторы и выражения с классом Friends.
</p>

<p>
    <strong>Выходные данные: </strong> Поведение объекта, как описано выше.
</p>


<p class="for_info_only">
    <strong>Как это используется: </strong>
    Здесь вы реализуете класс с изменяемым состоянием.
    Это не простая структура данных с несколькими методами, а реализация более сложного объекта.

</p>

<p>
    <strong>Предусловие:</strong>
    Все данные корректны.
</p>
